scMerge::eigenResidop
?add_ticks
t3 = Sys.time()
sce_mESC <- scMerge(sce_mESC,
ctl = segList_ensemblGeneID$mouse$mouse_scSEG,
kmeansK = c(1,3,3,1,1),
assay_name = "scMerge_fast",
fast_svd = TRUE,
rsvd_prop = 0.1)
t4 = Sys.time()
t4 - t3
metadata(sce_mESC)
sce_mESC <- scater::runPCA(sce_mESC,
exprs_values = "scMerge_fast")
scater::plotPCA(sce_mESC,
colour_by = "cellTypes",
shape_by = "batch") +
labs(title = "fast_svd yields similar results to the default version")
plotPCA
?proxy
??proxy
install.packages("parallel")
?BiocManager::install
library(pkgdown)
build_site()
library(roxygen2)
devtools::use_testthat()
usethis::use_testthat()
library(testthat)
library(scMerge)
test_check("scMerge")
?context
expect_equal(10, 10)
expect_equal(10, 11)
context("fastRUVIII")
L = scMerge::ruvSimulate(m = 800, n = 1000, nc = 50, nRep = 10)
context("fastRUVIII")
## Generate a simulated data to test on the speed of our improved algorithm
L = scMerge::ruvSimulate(m = 800, n = 1000, nc = 50, nRep = 10)
Y = L$Y; M = L$M; ctl = L$ctl
t1 = Sys.time()
improved1 = scMerge::fastRUVIII(Y = Y, M = M, ctl = ctl, k = 20, fast_svd = FALSE)
t2 = Sys.time()
improved2 = scMerge::fastRUVIII(Y = Y, M = M, ctl = ctl, k = 20, fast_svd = TRUE, rsvd_prop = 0.1)
t3 = Sys.time()
old = ruv::RUVIII(Y = Y, M = M, ctl = ctl, k = 20)
t4 = Sys.time()
expect_equal(improved1, old)
expect_equal(improved2, old)
expect_error(improved2, old)
expect_less_than
?expect_less_than
expect_lt(t2 - t1, t4 - t3)
t2 - t1
t4 - t3
as.numeric(t2 - t1, units = "sec")
as.numeric(t2 - t1, units = "secs")
expect_lt(as.numeric(t2 - t1, units = "secs"),
as.numeric(t4 - t5, units = "secs"))
expect_lt(as.numeric(t2 - t1, units = "secs"),
as.numeric(t4 - t3, units = "secs"))
## improved2 used RSVD, hence it should be faster than improved1
expect_lt(as.numeric(t3 - t2, units = "secs"),
as.numeric(t4 - t5, units = "secs"))
## improved2 used RSVD, hence it should be faster than improved1
expect_lt(as.numeric(t3 - t2, units = "secs"),
as.numeric(t4 - t3, units = "secs"))
as.numeric(t3 - t2, units = "secs")
as.numeric(t4 - t3, units = "secs")
## improved2 used RSVD, hence it should be faster than old
expect_lt(as.numeric(t3 - t2, units = "secs"),
as.numeric(t4 - t3, units = "secs"))
expect_lt(as.numeric(t2 - t1, units = "secs"),
as.numeric(t3 - t2, units = "secs"))
as.numeric(t2 - t1, units = "secs"),
as.numeric(t3 - t2, units = "secs")
as.numeric(t2 - t1, units = "secs")
as.numeric(t3 - t2, units = "secs")
## improved2 used RSVD, hence it should be faster than improved1
expect_lt(as.numeric(t3 - t2, units = "secs"),
as.numeric(t2 - t1, units = "secs"))
## improved1 used C++ matrix operations, hence it should be faster than native R matrix operations
expect_identical(improved1, old)
## improved1 used C++ matrix operations, hence it should be faster than native R matrix operations
expect_equal(improved1, old)
roxygenise()
## Generate a simulated data to test on the speed of our improved algorithm
L = scMerge::ruvSimulate(m = 800, n = 1000, nc = 50, nRep = 10)
Y = L$Y; M = L$M; ctl = L$ctl
t1 = Sys.time()
improved1 = scMerge::fastRUVIII(Y = Y, M = M, ctl = ctl, k = 20, fast_svd = FALSE)
t2 = Sys.time()
improved2 = scMerge::fastRUVIII(Y = Y, M = M, ctl = ctl, k = 20, fast_svd = TRUE, rsvd_prop = 0.1)
t3 = Sys.time()
old = ruv::RUVIII(Y = Y, M = M, ctl = ctl, k = 20)
t4 = Sys.time()
## improved1 used C++ matrix operations, hence it should be faster than native R matrix operations
expect_equal(improved1, old)
expect_lt(as.numeric(t2 - t1, units = "secs"),
as.numeric(t4 - t3, units = "secs"))
as.numeric(t2 - t1, units = "secs")
as.numeric(t4 - t3, units = "secs")
as.numeric(t3 - t2, units = "secs")
as.numeric(t4 - t3, units = "secs")
## improved2 used RSVD, hence it should be faster than improved1
expect_lt(as.numeric(t3 - t2, units = "secs"),
as.numeric(t2 - t1, units = "secs"))
#' L = ruvSimulate(m = 500, n = 20000, nRep = 10, lambda = 0.1)
#' Y = L$Y; M = L$M;
#'
#' system.time(scMerge::eigenResidop(Y, M))
#' system.time(ruv::residop(Y, M))
#'
context("Testing speed of cpp matrix operations")
## Generate a simulated data to test on the speed of our improved matrix operations
L = ruvSimulate(m = 500, n = 20000, nRep = 10, lambda = 0.1)
Y = L$Y; M = L$M;
t1 = Sys.time()
improved1 = scMerge::eigenResidop(Y, M)
t2 = Sys.time()
old = ruv::residop(Y, M)
t3 = Sys.time()
expect_equal(improved1, old)
## improved1 used C++ matrix operations, hence it should be faster than native R matrix operations
expect_equal(improved1, old)
expect_lt(as.numeric(t2 - t1, units = "secs"),
as.numeric(t3 - t2, units = "secs"))
old
dim(improved1)
dim(old)
## improved1 used C++ matrix operations, hence it should be faster than native R matrix operations
expect_equal(improved1, old)
dimnames(old)
dimnames(improved1)
?expect_equal
## improved1 used C++ matrix operations, hence it should be faster than native R matrix operations
expect_equal(improved1, old, use.names = FALSE)
## improved1 used C++ matrix operations, hence it should be faster than native R matrix operations
expect_equal(improved1, old, check.names = FALSE)
## improved1 used C++ matrix operations, hence it should be faster than native R matrix operations
expect_equal(improved1, old, all.names = FALSE)
## improved1 used C++ matrix operations, hence it should be faster than native R matrix operations
expect_equal(improved1, old, use.names = FALSE)
context("Testing speed of cpp matrix operations")
## Generate a simulated data to test on the speed of our improved matrix operations
L = ruvSimulate(m = 500, n = 20000, nRep = 10, lambda = 0.1)
Y = L$Y; M = L$M;
t1 = Sys.time()
improved1 = unname(scMerge::eigenResidop(Y, M))
t2 = Sys.time()
old = unname(ruv::residop(Y, M))
t3 = Sys.time()
## improved1 used C++ matrix operations, hence it should be faster than native R matrix operations
expect_identical(improved1, old)
expect_lt(as.numeric(t2 - t1, units = "secs"),
as.numeric(t3 - t2, units = "secs"))
## improved1 used C++ matrix operations, hence it should be faster than native R matrix operations
expect_equal(improved1, old, tolerance = 1e-7)
expect_lt(as.numeric(t2 - t1, units = "secs"),
as.numeric(t3 - t2, units = "secs"))
as.numeric(t2 - t1, units = "secs")
as.numeric(t3 - t2, units = "secs")
roxygenise()
roxygenise()
roxygenise()
context("Testing sce_cbind function")
# Loading required data
require(SingleCellExperiment)
data("sce_mESC", package = "scMerge.data")
batchNames<-unique(sce_mESC$batch)
batchNames
sce_mESC
## The example sce_mESC data contains 5 different batches. We will split this data by batches first and combine it
batchNames = unique(sce_mESC$batch)
sce_split<-list(
sce_mESC[,sce_mESC$batch==batchNames[1]],
sce_mESC[,sce_mESC$batch==batchNames[2]],
sce_mESC[,sce_mESC$batch==batchNames[3]],
sce_mESC[,sce_mESC$batch==batchNames[4]],
sce_mESC[,sce_mESC$batch==batchNames[5]]
)
rm(list=ls())
context("Testing sce_cbind function")
## Loading required data
require(SingleCellExperiment)
data("sce_mESC", package = "scMerge.data")
## The example sce_mESC data contains 5 different batches. We will split this data by batches first and combine it
batch_names = unique(sce_mESC$batch)
sce_split = list(
sce_mESC[,sce_mESC$batch == batch_names[1]],
sce_mESC[,sce_mESC$batch == batch_names[2]],
sce_mESC[,sce_mESC$batch == batch_names[3]],
sce_mESC[,sce_mESC$batch == batch_names[4]],
sce_mESC[,sce_mESC$batch == batch_names[5]]
)
sce_combine = sce_cbind(sce_list, batch_names = batch_names)
sce_combine = sce_cbind(sce_list = sce_split, batch_names = batch_names)
expect_equal(sce_mESC, sce_combine)
dim(sce_mESC)
dim(sce_combine)
sce_combine = sce_cbind(sce_list = sce_split,
batch_names = batch_names,
cut_off_batch = 0,
cut_off_overall = 0,
method = "union",
exprs = c("counts", "logcounts"),
colData_names = NULL)
expect_equal(sce_mESC, sce_combine)
dim(sce_mESC)
dim(sce_combine)
expect_identical(dim(sce_mESC), dim(sce_combine))
assays(sce_mESC)
assays(sce_combine)
assays(sce_mESC)
assays(sce_combine)
assays(sce_mESC) %>% class
assays(sce_combine) %>% class
colData(sce_mESC)
colData(sce_mESC)
colData(sce_combine)
expect_identical(colData(sce_mESC), colData(sce_combine))
## Talk to YXL about this
# expect_identical(colData(sce_mESC), colData(sce_combine))
colData(sce_mESC)$batch
colData(sce_combine)$batch
## Talk to YXL about this
# expect_identical(colData(sce_mESC), colData(sce_combine))
colData(sce_mESC)$batch
## Talk to YXL about this
# expect_identical(colData(sce_mESC), colData(sce_combine))
expect_identical(colData(sce_mESC)$batch, colData(sce_combine)$batch)
microbenchmark::microbenchmark(
x = rnorm(1e6),
times = 10
)
microbenchmark::microbenchmark(
x = rnorm(1e6),
mean(x),
times = 10
)
x = rnorm(1e6)
microbenchmark::microbenchmark(
mean(x),
times = 10
)
x = rnorm(1e6)
microbenchmark::microbenchmark(
mean(x),
sum(x)/length(x)
times = 10
)
x = rnorm(1e6)
microbenchmark::microbenchmark(
mean(x),
sum(x)/length(x),
times = 10
)
x = rpois(1e6)
x = rpois(1e6)
microbenchmark::microbenchmark(
mean(x == 0),
sum(x == 0)/length(x),
times = 10
)
x = rpois(1e6)
microbenchmark::microbenchmark(
mean(x == 0),
sum(x == 0)/length(x),
times = 100
)
x = rpois(1e7)
microbenchmark::microbenchmark(
mean(x == 0),
sum(x == 0)/length(x),
times = 100
)
x = rpois(1e8)
microbenchmark::microbenchmark(
mean(x == 0),
sum(x == 0)/length(x),
times = 100
)
x = rpois(1e10)
microbenchmark::microbenchmark(
mean(x == 0),
sum(x == 0)/length(x),
times = 100
)
identical( mean(x == 0),
sum(x == 0)/length(x))
colData(sce_mESC)
sce_combine = sce_cbind(sce_list = sce_split,
batch_names = batch_names,
cut_off_batch = 0,
cut_off_overall = 0,
method = "union",
exprs = c("counts", "logcounts"),
colData_names = c("cellTypes"))
expect_identical(dim(sce_mESC), dim(sce_combine))
expect_identical(colData(sce_mESC), colData(sce_combine))
roxygenise()
roxygenise()
sce_combine = sce_cbind(sce_list = sce_split,
batch_names = batch_names,
cut_off_batch = 0,
cut_off_overall = 0,
method = NULL,
exprs = c("counts", "logcounts"),
colData_names = c("cellTypes"))
roxygenise()
sce_combine = sce_cbind(sce_list = sce_split,
batch_names = batch_names,
cut_off_batch = 0,
cut_off_overall = 0,
method = NULL,
exprs = c("counts", "logcounts"),
colData_names = c("cellTypes"))
?message
message("As method is NULL, we will use the union method. \n")
message("As method is NULL, we will use the union method. \n", "adga")
message("The assay named ", exprs[1], " will be used to determine the proportion of zeroes for each batch")
exprs[1]
exprs = c("counts", "logcounts")
message("The assay named ", exprs[1], " will be used to determine the proportion of zeroes for each batch")
message("The assay named '", exprs[1], "' will be used to determine the proportion of zeroes for each batch")
?assay
expect_identical(sce_mESC, sce_combine)
sce_mESC@reducedDims
sce_combine@reducedDims
sce_mESC@assays
sce_combine@assays
identical(sce_combine@reducedDims, sce_mESC@assays)
all.equal(sce_combine@reducedDims, sce_mESC@assays)
all.equal(sce_mESC@assays, sce_combine@assays)
sce_combine@assays %>% class
sce_mESC@assays %>% class
all.equal(sce_mESC@assays, sce_combine@assays)
all.equal(class(sce_mESC@assays), class(sce_combine@assays))
sce_mESC@int_colData
sce_mESC@int_metadata
expect_identical(sce_mESC@int_metadata, sce_combine@int_metadata)
sce_mESC@int_metadata
sce_combine@int_metadata
source('~/Dropbox (Sydney Uni)/Single Cell Reserach/SCProj-Normalization/codes/scMerge/tests/testthat/test-sce_cbind.R', echo=TRUE)
expect_identical(sce_mESC@reducedDims, sce_combine@reducedDims)
sce_mESC@reducedDims
sce_mESC@reducedDims
sce_combine@reducedDims
expect_identical(sce_mESC@assays, sce_combine@assays)
expect_equal(sce_mESC@assays, sce_combine@assays)
expect_error(
sce_cbind(sce_list = sce_split)
)
expect_error(
sce_cbind(sce_list = sce_split,
method = "all")
)
testthat::expect_cpp_tests_pass()
testthat::expect_cpp_tests_pass("scMerge")
?expect_cpp_tests_pass
use_catch()
roxygenise()
roxygenise()
?useDynLib
useDynLib()
useDynLib(scMerge, .registration = TRUE)
namespace_roclet()
vignette("namespace", package = "roxygen2")
roxygenise()
roxygenise()
roxygenise()
roxygenise()
# Chunk 1: setup
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
# Chunk 2: loading packages
suppressPackageStartupMessages({
library(SingleCellExperiment)
library(scMerge)
library(scMerge.data)
library(scater)
})
# Chunk 3: loading data
## mouse ESC data
data("sce_mESC", package = "scMerge.data")
## single-cell stably expressed gene list
data("segList_ensemblGeneID")
# Chunk 4: checking raw data
table(sce_mESC$batch, sce_mESC$cellTypes)
scater::plotPCA(sce_mESC,
colour_by = "cellTypes",
shape_by = "batch")
scater::plotPCA(sce_mESC,
colour_by = "cellTypes",
shape_by = "batch",
add_ticks = FALSE)
warnings()
scater::plotPCA(sce_mESC,
colour_by = "cellTypes",
shape_by = "batch",
add_ticks = FALSE) +
geom_rug(...)
scater::plotPCA(sce_mESC,
colour_by = "cellTypes",
shape_by = "batch",
add_ticks = FALSE) +
geom_rug()
scater::plotPCA(sce_mESC,
colour_by = "cellTypes",
shape_by = "batch") +
geom_rug()
scater::plotPCA(sce_mESC,
colour_by = "cellTypes",
shape_by = "batch",
add_ticks = FALSE)
scater::plotPCA
args(scater::plotPCA)
args("scater::plotPCA")
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("scater", version = "3.8")
# Chunk 1: setup
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
# Chunk 2: loading packages
suppressPackageStartupMessages({
library(SingleCellExperiment)
library(scMerge)
library(scMerge.data)
library(scater)
})
# Chunk 3: loading data
## mouse ESC data
data("sce_mESC", package = "scMerge.data")
## single-cell stably expressed gene list
data("segList_ensemblGeneID")
table(sce_mESC$batch, sce_mESC$cellTypes)
scater::plotPCA(sce_mESC,
colour_by = "cellTypes",
shape_by = "batch",
add_ticks = FALSE)
scater::plotPCA(sce_mESC,
colour_by = "cellTypes",
shape_by = "batch")
roxygen2::roxygenise()
roxygen2::roxygenise()
library(roxygen2)
roxygen2::roxygenise()
roxygenise()
roxygenise()
iterators
install.packages("iterators")
install.packages("iterators")
roxygenise()
roxygenise()
library(pkgdown)
build_site()
build_site()
build_site()
context("Testing sce_cbind function")
## Loading required data
require(SingleCellExperiment)
data("sce_mESC", package = "scMerge.data")
library(testthat)
context("Testing sce_cbind function")
## Loading required data
require(SingleCellExperiment)
data("sce_mESC", package = "scMerge.data")
## A simple case: The sce_mESC example data contains 5 different batches. We will split this data by batches first and combine it
batch_names = unique(sce_mESC$batch)
sce_split = list(
sce_mESC[,sce_mESC$batch == batch_names[1]],
sce_mESC[,sce_mESC$batch == batch_names[2]],
sce_mESC[,sce_mESC$batch == batch_names[3]],
sce_mESC[,sce_mESC$batch == batch_names[4]],
sce_mESC[,sce_mESC$batch == batch_names[5]]
)
## Testing if the combination yields the same outputs
sce_combine = sce_cbind(sce_list = sce_split,
batch_names = batch_names,
cut_off_batch = 0,
cut_off_overall = 0,
method = NULL,
exprs = c("counts", "logcounts"),
colData_names = c("cellTypes"))
# expect_identical(sce_mESC, sce_combine)
# expect_equal(sce_mESC@assays, sce_combine@assays)
# expect_identical(sce_mESC@int_metadata, sce_combine@int_metadata)
# expect_identical(sce_mESC@reducedDims, sce_combine@reducedDims)
expect_identical(dim(sce_mESC), dim(sce_combine))
expect_identical(colData(sce_mESC), colData(sce_combine))
expect_identical(colData(sce_mESC)$batch, colData(sce_combine)$batch)
expect_error(
sce_cbind(sce_list = sce_split,
method = "all")
)
library(scMerge)
context("Testing speed of cpp matrix operations")
## Generate a simulated data to test on the speed of our improved matrix operations
L = ruvSimulate(m = 500, n = 20000, nRep = 10, lambda = 0.1)
Y = L$Y; M = L$M;
t1 = Sys.time()
improved1 = unname(scMerge::eigenResidop(Y, M))
t2 = Sys.time()
old = unname(ruv::residop(Y, M))
t3 = Sys.time()
as.numeric(t2 - t1, units = "secs")
as.numeric(t3 - t2, units = "secs")
