if (!is.null(parallelParam)) {
message("Computation will run in parallel using supplied parameters")
}
## If parallel is TRUE, but user did not supplied a parallelParam class, then we set it to bpparam()
if (parallel & is.null(parallelParam)) {
message("Computation will run in parallel using BiocParallel::bpparam()")
parallelParam = BiocParallel::bpparam()
}
## If parallel is FALSE, or the user did not supplied a parallelParam class, we will use SerialParam()
if (!parallel | is.null(parallelParam)) {
message("Computation will run in serial")
parallelParam = BiocParallel::SerialParam()
}
## Checking input expression assay name in SCE object
if (!exprs %in% SummarizedExperiment::assayNames(sce_combine)) {
stop(paste("No assay named", exprs))
}
## Extracting data matrix from SCE object
exprs_mat <- SummarizedExperiment::assay(sce_combine, exprs)
if (class(exprs_mat) != "matrix") {
stop(paste0("The assay named '", exprs, "' must be of class 'matrix', please convert this."))
}
sce_rownames <- rownames(sce_combine)
## Checking if any rows or columns are purely zeroes
if (sum(rowSums(exprs_mat) == 0) != 0 | sum(colSums(exprs_mat) == 0) != 0) {
stop("There are rows or columns that are all zeros in the expression matrix. Please remove these rows/columns.")
}
## Checking negative controls input
if (is.null(ctl)) {
stop("Negative control genes are needed. \n")
} else {
if (class(ctl) == "character") {
ctl <- which(sce_rownames %in% ctl)
}
if (length(ctl) == 0) {
stop("Could not find any negative control genes in the row names of the expression matrix", call. = FALSE)
}
}
## Checking the batch info
if (is.null(sce_combine$batch)) {
stop("Could not find a 'batch' column in colData(sce_combine)", call. = FALSE)
}
if (class(sce_combine$batch) == "factor") {
sce_batch <- droplevels(sce_combine$batch)
} else {
sce_batch <- sce_combine$batch
}
## Finding pseudo-replicates
t1 <- Sys.time()
repMat <- scReplicate(sce = sce_combine, batch = sce_batch, kmeansK = kmeansK, exprs = exprs, hvg_exprs = hvg_exprs, marker = marker, marker_list = marker_list,
replicate_prop = replicate_prop, cell_type = cell_type, cell_type_match = cell_type_match, cell_type_inc = cell_type_inc, dist = dist, WV = WV,
WV_marker = WV_marker, parallelParam = parallelParam, fast_svd = fast_svd)
t2 <- Sys.time()
timeReplicates <- t2 - t1
repMat
repMat %>% head
rm(list=ls())
context("Testing identical results when permuting columns")
library(SingleCellExperiment)
library(scater)
library(scMerge)
## Loading example data
data('example_sce', package = 'scMerge')
## Previously computed stably expressed genes
data('segList_ensemblGeneID', package = 'scMerge')
## Running an example data with minimal inputs
######################################
example_sce1 = example_sce
res1 = scMerge(sce_combine = example_sce1,
ctl = segList_ensemblGeneID$mouse$mouse_scSEG,
kmeansK = c(3, 3),
assay_name = 'scMerge1',
replicate_prop = 1,
# cell_type = example_sce1$cellTypes,
return_all_RUV = TRUE
)
context("Testing identical results when permuting columns")
library(SingleCellExperiment)
library(scater)
library(scMerge)
## Loading example data
data('example_sce', package = 'scMerge')
## Previously computed stably expressed genes
data('segList_ensemblGeneID', package = 'scMerge')
## Running an example data with minimal inputs
######################################
example_sce1 = example_sce
res1 = scMerge(sce_combine = example_sce1,
ctl = segList_ensemblGeneID$mouse$mouse_scSEG,
kmeansK = c(3, 3),
assay_name = 'scMerge1',
replicate_prop = 1,
# cell_type = example_sce1$cellTypes,
return_all_RUV = TRUE
)
dev.off()
context("Testing identical results when permuting columns")
library(SingleCellExperiment)
library(scater)
library(scMerge)
## Loading example data
data('example_sce', package = 'scMerge')
## Previously computed stably expressed genes
data('segList_ensemblGeneID', package = 'scMerge')
## Running an example data with minimal inputs
######################################
example_sce1 = example_sce
res1 = scMerge(sce_combine = example_sce1,
ctl = segList_ensemblGeneID$mouse$mouse_scSEG,
kmeansK = c(3, 3),
assay_name = 'scMerge1',
replicate_prop = 1,
# cell_type = example_sce1$cellTypes,
return_all_RUV = TRUE
)
context("Testing identical results when permuting columns")
library(SingleCellExperiment)
library(scater)
library(scMerge)
## Loading example data
data('example_sce', package = 'scMerge')
## Previously computed stably expressed genes
data('segList_ensemblGeneID', package = 'scMerge')
## Running an example data with minimal inputs
######################################
example_sce1 = example_sce
res1 = scMerge(sce_combine = example_sce1,
ctl = segList_ensemblGeneID$mouse$mouse_scSEG,
kmeansK = c(3, 3),
assay_name = 'scMerge1',
replicate_prop = 1,
# cell_type = example_sce1$cellTypes,
return_all_RUV = TRUE
)
context("Testing identical results when permuting columns")
library(SingleCellExperiment)
library(scater)
library(scMerge)
## Loading example data
data('example_sce', package = 'scMerge')
## Previously computed stably expressed genes
data('segList_ensemblGeneID', package = 'scMerge')
## Running an example data with minimal inputs
######################################
example_sce1 = example_sce
res1 = scMerge(sce_combine = example_sce1,
ctl = segList_ensemblGeneID$mouse$mouse_scSEG,
kmeansK = c(3, 3),
assay_name = 'scMerge1',
replicate_prop = 1,
# cell_type = example_sce1$cellTypes,
return_all_RUV = TRUE
)
# sce_combine = example_sce1
# assay_name = 'scMerge1'
#
# ctl = segList_ensemblGeneID$mouse$mouse_scSEG
# kmeansK = c(3, 3)
# replicate_prop = 1
# return_all_RUV = TRUE
# exprs = "logcounts"; hvg_exprs = "counts";
# marker = NULL; marker_list = NULL;
# ruvK = 20; cell_type = NULL; cell_type_match = FALSE; cell_type_inc = NULL;
# fast_svd = FALSE; rsvd_prop = 0.1; dist = "cor"; WV = NULL;
# WV_marker = NULL; parallel = FALSE;
# parallelParam = NULL; return_all_RUV = FALSE;
#
#
#
# assay(res1, "scMerge1")[1:5,1:5]
# assay(res2, "scMerge2")[1:5,1:5]
######################################
set.seed(2)
example_sce2 = example_sce[,sample(seq_len(ncol(example_sce)))]
res2 = scMerge(sce_combine = example_sce2,
ctl = segList_ensemblGeneID$mouse$mouse_scSEG,
kmeansK = c(3, 3),
assay_name = 'scMerge2', replicate_prop = 1,
return_all_RUV = TRUE
)
######################################
scater::plotPCA(res1, colour_by = 'cellTypes', shape = 'batch',
run_args = list(exprs_values = 'scMerge1'), add_ticks = FALSE)
scater::plotPCA(res2, colour_by = 'cellTypes', shape = 'batch',
run_args = list(exprs_values = 'scMerge2'), add_ticks = FALSE)
repMat1 = metadata(res1)$scRep_res
repMat2 = metadata(res2)$scRep_res
all.equal(repMat1, repMat2)
colSums(repMat1)
colSums(repMat2)
table(repMat1[, 1], repMat2[,which(colSums(repMat2) == colSums(repMat1)[1])])
table(repMat1[, 2], repMat2[,which(colSums(repMat2) == colSums(repMat1)[2])])
table(repMat1[, 3], repMat2[,which(colSums(repMat2) == colSums(repMat1)[3])])
rm(list=ls())
context("Testing identical results when permuting columns")
library(SingleCellExperiment)
library(scater)
library(scMerge)
## Loading example data
data('example_sce', package = 'scMerge')
## Previously computed stably expressed genes
data('segList_ensemblGeneID', package = 'scMerge')
## Running an example data with minimal inputs
######################################
example_sce1 = example_sce
sce_combine = example_sce1
assay_name = 'scMerge1'
ctl = segList_ensemblGeneID$mouse$mouse_scSEG
kmeansK = c(3, 3)
replicate_prop = 1
return_all_RUV = TRUE
exprs = "logcounts"; hvg_exprs = "counts";
marker = NULL; marker_list = NULL;
ruvK = 20; cell_type = NULL; cell_type_match = FALSE; cell_type_inc = NULL;
fast_svd = FALSE; rsvd_prop = 0.1; dist = "cor"; WV = NULL;
WV_marker = NULL; parallel = FALSE;
parallelParam = NULL; return_all_RUV = FALSE;
assay(res1, "scMerge1")[1:5,1:5]
assay(res2, "scMerge2")[1:5,1:5]
######################################
set.seed(2)
example_sce2 = example_sce[,sample(seq_len(ncol(example_sce)))]
rm(example_sce2)
## Checking input expression
if (is.null(exprs)) {
stop("exprs is NULL.")
}
if (is.null(assay_name)) {
stop("assay_name is NULL, please provide a name to store the results under")
}
if (return_all_RUV) {
message("You chose return_all_RUV = TRUE, the result will contain all RUV computations. This could be a very large object.")
## We need an assay_name for every ruvK, if return_all_RUV is TRUE
if (length(assay_name) != length(ruvK)) {
stop("You chose return_all_RUV = TRUE. In this case, the length of assay_name must be equal to the length of ruvK")
}
}
## If the user supplied a parallelParam class, then regardless of parallel = TRUE or FALSE, we will use that class Hence no if statement for this
## case.
if (!is.null(parallelParam)) {
message("Computation will run in parallel using supplied parameters")
}
## If parallel is TRUE, but user did not supplied a parallelParam class, then we set it to bpparam()
if (parallel & is.null(parallelParam)) {
message("Computation will run in parallel using BiocParallel::bpparam()")
parallelParam = BiocParallel::bpparam()
}
## If parallel is FALSE, or the user did not supplied a parallelParam class, we will use SerialParam()
if (!parallel | is.null(parallelParam)) {
message("Computation will run in serial")
parallelParam = BiocParallel::SerialParam()
}
## Checking input expression assay name in SCE object
if (!exprs %in% SummarizedExperiment::assayNames(sce_combine)) {
stop(paste("No assay named", exprs))
}
## Extracting data matrix from SCE object
exprs_mat <- SummarizedExperiment::assay(sce_combine, exprs)
if (class(exprs_mat) != "matrix") {
stop(paste0("The assay named '", exprs, "' must be of class 'matrix', please convert this."))
}
sce_rownames <- rownames(sce_combine)
## Checking if any rows or columns are purely zeroes
if (sum(rowSums(exprs_mat) == 0) != 0 | sum(colSums(exprs_mat) == 0) != 0) {
stop("There are rows or columns that are all zeros in the expression matrix. Please remove these rows/columns.")
}
## Checking negative controls input
if (is.null(ctl)) {
stop("Negative control genes are needed. \n")
} else {
if (class(ctl) == "character") {
ctl <- which(sce_rownames %in% ctl)
}
if (length(ctl) == 0) {
stop("Could not find any negative control genes in the row names of the expression matrix", call. = FALSE)
}
}
## Checking the batch info
if (is.null(sce_combine$batch)) {
stop("Could not find a 'batch' column in colData(sce_combine)", call. = FALSE)
}
if (class(sce_combine$batch) == "factor") {
sce_batch <- droplevels(sce_combine$batch)
} else {
sce_batch <- sce_combine$batch
}
## Finding pseudo-replicates
t1 <- Sys.time()
repMat <- scReplicate(sce = sce_combine, batch = sce_batch, kmeansK = kmeansK, exprs = exprs, hvg_exprs = hvg_exprs, marker = marker, marker_list = marker_list,
replicate_prop = replicate_prop, cell_type = cell_type, cell_type_match = cell_type_match, cell_type_inc = cell_type_inc, dist = dist, WV = WV,
WV_marker = WV_marker, parallelParam = parallelParam, fast_svd = fast_svd)
t2 <- Sys.time()
timeReplicates <- t2 - t1
repMat[1:5, ]
colSums(repMat)
repMat[,1]
sce_combine = example_sce1
assay_name = 'scMerge1'
sce = example_sce1
batch = example_sce1$batch
exprs_mat <- SummarizedExperiment::assay(sce, exprs)
## Based on the input cell_type info, we decide which version of scMerge to use.
if (!is.null(cell_type) & is.null(cell_type_inc) & !cell_type_match) {
cat("Cell type information was supplied, and mutual nearest neighbour option was not selected \n")
cat("Performing supervised scMerge \n")
names(cell_type) <- colnames(exprs_mat)
repVector <- supervisedReplicate(exprs_mat, cell_type, replicate_prop)
mnc_res <- NULL
} else if (!is.null(cell_type) & is.null(cell_type_inc) & cell_type_match) {
cat("Cell type information was supplied, and mutual nearest neighbour option was selected \n")
cat("Finding MNC from the known cell types of different batches...\n")
names(cell_type) <- colnames(exprs_mat)
batch <- as.factor(batch)
batch_list <- as.list(as.character(unique(batch)))
## Finding data-adaptive markers, store as object as HVG
if (is.null(marker) & is.null(marker_list)) {
cat("No maker nor marker_list information was supplied \n")
cat("Finding HVG...\n")
exprs_mat_HVG <- SummarizedExperiment::assay(sce, hvg_exprs)
HVG_res <- findHVG(exprs_mat_HVG, batch, parallelParam = parallelParam)
HVG <- HVG_res$HVG
HVG_list <- HVG_res$HVG_list
} else if (!is.null(marker_list) & is.null(marker)) {
## Taking the union of marker_list as HVG
cat("Only marker_list information was supplied \n")
HVG_list <- marker_list
names(HVG_list) <- batch_list
HVG <- Reduce(union, marker_list)
} else {
## If there is only a list of markers, then use that as HVG
HVG <- marker
}
# sce$batch <- as.factor(sce$batch) batch_list <- as.list(as.character(unique(sce$batch)))
## For every unique cell_type, calculate the centroid.
clustering_distProp <- lapply(unique(cell_type), function(x) centroidDist(exprs_mat[, cell_type == x]))
clustering_distProp <- unlist(clustering_distProp)[names(cell_type)]
## For each batch in batch_list, we find the corresponding cell_type_centroid
clustering_distProp_list_batch <- lapply(batch_list, function(x) {
tmp <- clustering_distProp[batch == x]
names(tmp) <- colnames(exprs_mat)[batch == x]
tmp
})
## For each batch in batch_list, we find the corresponding cell_type
cellType_list_batch <- lapply(batch_list, function(x) {
tmp <- as.numeric(droplevels(as.factor(cell_type[batch == x])))
names(tmp) <- colnames(exprs_mat)[batch == x]
tmp
})
## Here, using the cell type information, we go ahead and find MNC
mnc_res <- findMNC(exprs_mat[HVG, ], clustering_list = cellType_list_batch, dist = dist, parallelParam = parallelParam)
print(mnc_res)
repVector <- mncReplicate(clustering_list = cellType_list_batch, clustering_distProp = clustering_distProp_list_batch, replicate_prop = replicate_prop,
mnc_df = mnc_res)
# if(!is.null(cell_type)&!is.null(cell_type_inc)){ cat('Performing semi-supervised scMerge with subsets of known cell type\n')
# repVector[cell_type_inc] <- cell_type[cell_type_inc] } repMat <- replicate.matrix(repVector)
} else {
batch <- as.factor(batch)
batch_list <- as.list(as.character(unique(batch)))
## KEVIN: we should move this input check much earlier, into scMerge function
if (is.null(kmeansK)) {
stop("KmeansK is NULL", call. = FALSE)
}
if (length(batch_list) != length(kmeansK)) {
stop("length of KmeansK needs to be the same as the number of batch", call. = FALSE)
}
## If there are no marker information what so ever, we find the HVG adaptively from the data
if (is.null(marker) & is.null(marker_list)) {
cat("No maker nor marker_list information was supplied \n")
cat("Finding HVG...\n")
exprs_mat_HVG <- SummarizedExperiment::assay(sce, hvg_exprs)
HVG_res <- findHVG(exprs_mat_HVG, batch, parallelParam = parallelParam)
HVG <- HVG_res$HVG
HVG_list <- HVG_res$HVG_list
} else if (!is.null(marker_list) & is.null(marker)) {
cat("Only marker_list information was supplied \n")
HVG_list <- marker_list
names(HVG_list) <- batch_list
HVG <- Reduce(union, marker_list)
} else {
HVG <- marker
}
# Clustering within each batch
cat("Clustering within each batch...\n")
cat("Performing pca...\n")
cluster_res <- identifyCluster(exprs_mat = exprs_mat, batch = batch, marker = marker, HVG_list = HVG_list, kmeansK = kmeansK, parallelParam = parallelParam,
fast_svd = fast_svd)
# Find Mutual Nearest Cluster
cat("Creating Mutual Nearest Cluster...\n")
# if (parallel) { mnc_res <- findMNC_parallel(exprs_mat[HVG, ], clustering_list = cluster_res$clustering_list, dist = dist, parallelParam =
# parallelParam) } else { mnc_res <- findMNC(exprs_mat[HVG, ], clustering_list = cluster_res$clustering_list, dist = dist) }
mnc_res <- findMNC(exprs_mat = exprs_mat[HVG, ], clustering_list = cluster_res$clustering_list, dist = dist, parallelParam = parallelParam)
print(mnc_res)
# Create replicate matrix
repVector <- mncReplicate(clustering_list = cluster_res$clustering_list,
clustering_distProp = cluster_res$clustering_distProp, replicate_prop = replicate_prop,
mnc_df = mnc_res)
if (!is.null(cell_type) & !is.null(cell_type_inc)) {
cat("Performing semi-supervised scMerge with subsets of known cell type\n")
repVector[cell_type_inc] <- cell_type[cell_type_inc]
}
if (!is.null(WV)) {
cat("Performing semi-supervised scMerge with wanted variation\n")
repVector <- wvReplicate(exprs_mat, WV, WV_marker, repVector)
}
}
roxygenise()
exprs_mat <- SummarizedExperiment::assay(sce, exprs)
## Based on the input cell_type info, we decide which version of scMerge to use.
if (!is.null(cell_type) & is.null(cell_type_inc) & !cell_type_match) {
cat("Cell type information was supplied, and mutual nearest neighbour option was not selected \n")
cat("Performing supervised scMerge \n")
names(cell_type) <- colnames(exprs_mat)
repVector <- supervisedReplicate(exprs_mat, cell_type, replicate_prop)
mnc_res <- NULL
} else if (!is.null(cell_type) & is.null(cell_type_inc) & cell_type_match) {
cat("Cell type information was supplied, and mutual nearest neighbour option was selected \n")
cat("Finding MNC from the known cell types of different batches...\n")
names(cell_type) <- colnames(exprs_mat)
batch <- as.factor(batch)
batch_list <- as.list(as.character(unique(batch)))
## Finding data-adaptive markers, store as object as HVG
if (is.null(marker) & is.null(marker_list)) {
cat("No maker nor marker_list information was supplied \n")
cat("Finding HVG...\n")
exprs_mat_HVG <- SummarizedExperiment::assay(sce, hvg_exprs)
HVG_res <- findHVG(exprs_mat_HVG, batch, parallelParam = parallelParam)
HVG <- HVG_res$HVG
HVG_list <- HVG_res$HVG_list
} else if (!is.null(marker_list) & is.null(marker)) {
## Taking the union of marker_list as HVG
cat("Only marker_list information was supplied \n")
HVG_list <- marker_list
names(HVG_list) <- batch_list
HVG <- Reduce(union, marker_list)
} else {
## If there is only a list of markers, then use that as HVG
HVG <- marker
}
# sce$batch <- as.factor(sce$batch) batch_list <- as.list(as.character(unique(sce$batch)))
## For every unique cell_type, calculate the centroid.
clustering_distProp <- lapply(unique(cell_type), function(x) centroidDist(exprs_mat[, cell_type == x]))
clustering_distProp <- unlist(clustering_distProp)[names(cell_type)]
## For each batch in batch_list, we find the corresponding cell_type_centroid
clustering_distProp_list_batch <- lapply(batch_list, function(x) {
tmp <- clustering_distProp[batch == x]
names(tmp) <- colnames(exprs_mat)[batch == x]
tmp
})
## For each batch in batch_list, we find the corresponding cell_type
cellType_list_batch <- lapply(batch_list, function(x) {
tmp <- as.numeric(droplevels(as.factor(cell_type[batch == x])))
names(tmp) <- colnames(exprs_mat)[batch == x]
tmp
})
## Here, using the cell type information, we go ahead and find MNC
mnc_res <- findMNC(exprs_mat[HVG, ], clustering_list = cellType_list_batch, dist = dist, parallelParam = parallelParam)
print(mnc_res)
repVector <- mncReplicate(clustering_list = cellType_list_batch, clustering_distProp = clustering_distProp_list_batch, replicate_prop = replicate_prop,
mnc_df = mnc_res)
# if(!is.null(cell_type)&!is.null(cell_type_inc)){ cat('Performing semi-supervised scMerge with subsets of known cell type\n')
# repVector[cell_type_inc] <- cell_type[cell_type_inc] } repMat <- replicate.matrix(repVector)
} else {
batch <- as.factor(batch)
batch_list <- as.list(as.character(unique(batch)))
## KEVIN: we should move this input check much earlier, into scMerge function
if (is.null(kmeansK)) {
stop("KmeansK is NULL", call. = FALSE)
}
if (length(batch_list) != length(kmeansK)) {
stop("length of KmeansK needs to be the same as the number of batch", call. = FALSE)
}
## If there are no marker information what so ever, we find the HVG adaptively from the data
if (is.null(marker) & is.null(marker_list)) {
cat("No maker nor marker_list information was supplied \n")
cat("Finding HVG...\n")
exprs_mat_HVG <- SummarizedExperiment::assay(sce, hvg_exprs)
HVG_res <- findHVG(exprs_mat_HVG, batch, parallelParam = parallelParam)
HVG <- HVG_res$HVG
HVG_list <- HVG_res$HVG_list
} else if (!is.null(marker_list) & is.null(marker)) {
cat("Only marker_list information was supplied \n")
HVG_list <- marker_list
names(HVG_list) <- batch_list
HVG <- Reduce(union, marker_list)
} else {
HVG <- marker
}
# Clustering within each batch
cat("Clustering within each batch...\n")
cat("Performing pca...\n")
cluster_res <- identifyCluster(exprs_mat = exprs_mat, batch = batch, marker = marker, HVG_list = HVG_list, kmeansK = kmeansK, parallelParam = parallelParam,
fast_svd = fast_svd)
# Find Mutual Nearest Cluster
cat("Creating Mutual Nearest Cluster...\n")
# if (parallel) { mnc_res <- findMNC_parallel(exprs_mat[HVG, ], clustering_list = cluster_res$clustering_list, dist = dist, parallelParam =
# parallelParam) } else { mnc_res <- findMNC(exprs_mat[HVG, ], clustering_list = cluster_res$clustering_list, dist = dist) }
mnc_res <- findMNC(exprs_mat = exprs_mat[HVG, ], clustering_list = cluster_res$clustering_list, dist = dist, parallelParam = parallelParam)
print(mnc_res)
# Create replicate matrix
repVector <- mncReplicate(clustering_list = cluster_res$clustering_list,
clustering_distProp = cluster_res$clustering_distProp, replicate_prop = replicate_prop,
mnc_df = mnc_res)
if (!is.null(cell_type) & !is.null(cell_type_inc)) {
cat("Performing semi-supervised scMerge with subsets of known cell type\n")
repVector[cell_type_inc] <- cell_type[cell_type_inc]
}
if (!is.null(WV)) {
cat("Performing semi-supervised scMerge with wanted variation\n")
repVector <- wvReplicate(exprs_mat, WV, WV_marker, repVector)
}
}
repVector
