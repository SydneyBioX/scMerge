## For each batch in batch_list, we find the corresponding cell_type_centroid
clustering_distProp_list_batch <- lapply(batch_list, function(x) {
tmp <- clustering_distProp[batch == x]
names(tmp) <- colnames(exprs_mat)[batch == x]
tmp
})
## For each batch in batch_list, we find the corresponding cell_type
cellType_list_batch <- lapply(batch_list, function(x) {
tmp <- as.numeric(droplevels(as.factor(cell_type[batch == x])))
names(tmp) <- colnames(exprs_mat)[batch == x]
tmp
})
## Here, using the cell type information, we go ahead and find MNC
mnc_res <- findMNC(exprs_mat[HVG, ], clustering_list = cluster_res$clustering_list,
dist = dist, parallelParam = parallelParam)
print(mnc_res)
repVector <- mncReplicate(clustering_list = cellType_list_batch, clustering_distProp = clustering_distProp_list_batch,
replicate_prop = replicate_prop, mnc_df = mnc_res)
# if(!is.null(cell_type)&!is.null(cell_type_inc)){ cat('Performing
# semi-supervised scMerge with subsets of known cell type\n')
# repVector[cell_type_inc] <- cell_type[cell_type_inc] } repMat <-
# replicate.matrix(repVector)
} else {
batch <- as.factor(batch)
batch_list <- as.list(as.character(unique(batch)))
## KEVIN: we should move this input check much earlier, into scMerge function
if (is.null(kmeansK)) {
stop("KmeansK is NULL", call. = FALSE)
}
if (length(batch_list) != length(kmeansK)) {
stop("length of KmeansK needs to be the same as the number of batch",
call. = FALSE)
}
## If there are no marker information what so ever, we find the HVG adaptively
## from the data
if (is.null(marker) & is.null(marker_list)) {
cat("No maker nor marker_list information was supplied \n")
cat("Finding HVG...\n")
exprs_mat_HVG <- SummarizedExperiment::assay(sce, hvg_exprs)
HVG_res <- findHVG(exprs_mat_HVG, batch, parallelParam = parallelParam)
HVG <- HVG_res$HVG
HVG_list <- HVG_res$HVG_list
} else if (!is.null(marker_list) & is.null(marker)) {
cat("Only marker_list information was supplied \n")
HVG_list <- marker_list
names(HVG_list) <- batch_list
HVG <- Reduce(union, marker_list)
} else {
HVG <- marker
}
# Clustering within each batch
cat("Clustering within each batch...\n")
cat("Performing pca...\n")
cluster_res <- identifyCluster(exprs_mat = exprs_mat, batch = batch, marker = marker,
HVG_list = HVG_list, kmeansK = kmeansK, parallelParam = parallelParam, fast_svd = fast_svd)
# Find Mutual Nearest Cluster
cat("Creating Mutual Nearest Cluster...\n")
# if (parallel) {
#   mnc_res <- findMNC_parallel(exprs_mat[HVG, ], clustering_list = cluster_res$clustering_list,
#                               dist = dist, parallelParam = parallelParam)
# } else {
#   mnc_res <- findMNC(exprs_mat[HVG, ], clustering_list = cluster_res$clustering_list,
#                      dist = dist)
# }
mnc_res <- findMNC(exprs_mat[HVG, ], clustering_list = cluster_res$clustering_list,
dist = dist, parallelParam = parallelParam)
print(mnc_res)
# Create replicate matrix
repVector <- mncReplicate(clustering_list = cluster_res$clustering_list,
clustering_distProp = cluster_res$clustering_distProp, replicate_prop = replicate_prop,
mnc_df = mnc_res)
if (!is.null(cell_type) & !is.null(cell_type_inc)) {
cat("Performing semi-supervised scMerge with subsets of known cell type\n")
repVector[cell_type_inc] <- cell_type[cell_type_inc]
}
if (!is.null(WV)) {
cat("Performing semi-supervised scMerge with wanted variation\n")
repVector <- wvReplicate(exprs_mat, WV, WV_marker, repVector)
}
}
repMat <- ruv::replicate.matrix(repVector)
context("Testing on scReplicate")
library(SingleCellExperiment)
library(scMerge)
library(scMerge.data)
## Loading example data
data("sce_mESC", package = "scMerge.data")
#################### Testing if the fast_svd option yields identical result ####################
set.seed(1)
t1 <- Sys.time()
scRep_fastF <- scReplicate(
sce = sce_mESC,
batch = sce_mESC$batch,
kmeansK = c(1,3,3,1,1),
fast_svd = FALSE)
context("Testing if parallelisation produce identical results")
## Loading required data
require(SingleCellExperiment)
data("sce_mESC", package = "scMerge.data")
data("segList_ensemblGeneID")
snow <- SnowParam(workers = 1, type = "FORK")
register(snow)
t1 = Sys.time()
pF <- scMerge(sce_mESC,
ctl = segList_ensemblGeneID$mouse$mouse_scSEG,
kmeansK = c(1,3,3,1,1),
assay_name = "scMerge_classical")
t2 = Sys.time()
t2 - t1
bpparam()
snow <- SnowParam(workers = 8, type = "FORK")
# system.time(x <- lapply(1:3, function(i) { Sys.sleep(i); i }))
# system.time(x <- bplapply(1:3, function(i) { Sys.sleep(i); i }, BPPARAM = SnowParam(workers = 1, type = "FORK")))
# system.time(x <- bplapply(1:3, function(i) { Sys.sleep(i); i }, BPPARAM = snow))
register(snow)
bpparam()
t3 = Sys.time()
pT <- scMerge(sce_mESC,
ctl = segList_ensemblGeneID$mouse$mouse_scSEG,
kmeansK = c(1,3,3,1,1),
assay_name = "scMerge_classical",
parallelParam = bpparam())
t4 = Sys.time()
t4 - t3
?
register
SerialParam()
BiocParallel::SerialParam()
BiocParallel::bpparam()
parallel
## If parallel is TRUE, but user did not supplied a parallelParam class, then we set it to bpparam()
if(parallel & is.null(parallelParam)){
parallelParam = BiocParallel::bpparam()
}
roxygenise()
context("Testing if parallelisation produce identical results")
## Loading required data
require(SingleCellExperiment)
data("sce_mESC", package = "scMerge.data")
data("segList_ensemblGeneID")
snow <- SnowParam(workers = 1, type = "FORK")
register(snow)
t1 = Sys.time()
pF <- scMerge(sce_mESC,
ctl = segList_ensemblGeneID$mouse$mouse_scSEG,
kmeansK = c(1,3,3,1,1),
assay_name = "scMerge_classical",
parallel = FALSE)
t2 = Sys.time()
t2 - t1
snow <- SnowParam(workers = 8, type = "FORK")
# system.time(x <- lapply(1:3, function(i) { Sys.sleep(i); i }))
# system.time(x <- bplapply(1:3, function(i) { Sys.sleep(i); i }, BPPARAM = SnowParam(workers = 1, type = "FORK")))
# system.time(x <- bplapply(1:3, function(i) { Sys.sleep(i); i }, BPPARAM = snow))
register(snow)
bpparam()
t3 = Sys.time()
pT <- scMerge(sce_mESC,
ctl = segList_ensemblGeneID$mouse$mouse_scSEG,
kmeansK = c(1,3,3,1,1),
assay_name = "scMerge_classical",
parallelParam = bpparam())
t4 = Sys.time()
t4 - t3
expect_identical(
assay(pF, "scMerge_classical"),
assay(pT, "scMerge_classical")
)
roxygenise()
context("Testing if parallelisation produce identical results")
## Loading required data
require(SingleCellExperiment)
data("sce_mESC", package = "scMerge.data")
data("segList_ensemblGeneID")
snow <- SnowParam(workers = 1, type = "FORK")
register(snow)
t1 = Sys.time()
pF <- scMerge(sce_mESC,
ctl = segList_ensemblGeneID$mouse$mouse_scSEG,
kmeansK = c(1,3,3,1,1),
assay_name = "scMerge_classical",
parallel = FALSE)
parallelParam = NULL
!is.null(parallelParam)
roxygenise()
context("Testing if parallelisation produce identical results")
## Loading required data
require(SingleCellExperiment)
data("sce_mESC", package = "scMerge.data")
data("segList_ensemblGeneID")
snow <- SnowParam(workers = 1, type = "FORK")
register(snow)
t1 = Sys.time()
pF <- scMerge(sce_mESC,
ctl = segList_ensemblGeneID$mouse$mouse_scSEG,
kmeansK = c(1,3,3,1,1),
assay_name = "scMerge_classical",
parallel = FALSE)
t2 = Sys.time()
t2 - t1
!is.null(parallelParam)
scMerge
context("Testing if parallelisation produce identical results")
## Loading required data
require(SingleCellExperiment)
data("sce_mESC", package = "scMerge.data")
data("segList_ensemblGeneID")
snow <- SnowParam(workers = 1, type = "FORK")
register(snow)
sce_mESC
ctl = segList_ensemblGeneID$mouse$mouse_scSEG
kmeansK = c(1,3,3,1,1)
assay_name = "scMerge_classical"
parallel = FALSE
parallelParam = NULL
## Checking input expression
if (is.null(exprs)) {
stop("exprs is NULL.")
}
if (is.null(assay_name)) {
stop("assay_name is NULL")
}
if (return_all_RUV) {
message("You chose return_all_RUV = TRUE, the result will contain all RUV computations. This could be a very large object.")
## We need an assay_name for every ruvK, if return_all_RUV is TRUE
if (length(assay_name) != length(ruvK)) {
stop("You chose return_all_RUV = TRUE. In this case, the length of assay_name must be equal to the length of ruvK")
}
}
## If the user supplied a parallelParam class, then  regardless of parallel = TRUE or FALSE, we will use that class
## Hence no if statement for this case.
if(!is.null(parallelParam)){
message("Computation will run in parallel using supplied parameters")
}
parallelParam
parallel
parallelParam
## If the user supplied a parallelParam class, then  regardless of parallel = TRUE or FALSE, we will use that class
## Hence no if statement for this case.
if(!is.null(parallelParam)){
message("Computation will run in parallel using supplied parameters")
}
## If parallel is TRUE, but user did not supplied a parallelParam class, then we set it to bpparam()
if(parallel & is.null(parallelParam)){
message("Computation will run in parallel using BiocParallel::bpparam()")
parallelParam = BiocParallel::bpparam()
}
## If parallel is FALSE, or the user did not supplied a parallelParam class, we will use SerialParam()
if(!parallel | is.null(parallelParam)){
message("Computation will run in serial")
parallelParam = BiocParallel::SerialParam()
}
parallelParam
parallel
parallel = TRUE
## If the user supplied a parallelParam class, then  regardless of parallel = TRUE or FALSE, we will use that class
## Hence no if statement for this case.
if(!is.null(parallelParam)){
message("Computation will run in parallel using supplied parameters")
}
## If the user supplied a parallelParam class, then  regardless of parallel = TRUE or FALSE, we will use that class
## Hence no if statement for this case.
if(!is.null(parallelParam)){
message("Computation will run in parallel using supplied parameters")
}
parallel
## If the user supplied a parallelParam class, then  regardless of parallel = TRUE or FALSE, we will use that class
## Hence no if statement for this case.
if(!is.null(parallelParam)){
message("Computation will run in parallel using supplied parameters")
}
## If parallel is TRUE, but user did not supplied a parallelParam class, then we set it to bpparam()
if(parallel & is.null(parallelParam)){
message("Computation will run in parallel using BiocParallel::bpparam()")
parallelParam = BiocParallel::bpparam()
}
parallel
parallelParam
parallelParam = NULL
## If the user supplied a parallelParam class, then  regardless of parallel = TRUE or FALSE, we will use that class
## Hence no if statement for this case.
if(!is.null(parallelParam)){
message("Computation will run in parallel using supplied parameters")
}
## If parallel is TRUE, but user did not supplied a parallelParam class, then we set it to bpparam()
if(parallel & is.null(parallelParam)){
message("Computation will run in parallel using BiocParallel::bpparam()")
parallelParam = BiocParallel::bpparam()
}
## If parallel is FALSE, or the user did not supplied a parallelParam class, we will use SerialParam()
if(!parallel | is.null(parallelParam)){
message("Computation will run in serial")
parallelParam = BiocParallel::SerialParam()
}
parallel
roxygenise()
context("Testing if parallelisation produce identical results")
## Loading required data
require(SingleCellExperiment)
data("sce_mESC", package = "scMerge.data")
data("segList_ensemblGeneID")
snow <- SnowParam(workers = 1, type = "FORK")
register(snow)
t1 = Sys.time()
pF <- scMerge(sce_mESC,
ctl = segList_ensemblGeneID$mouse$mouse_scSEG,
kmeansK = c(1,3,3,1,1),
assay_name = "scMerge_classical",
parallel = FALSE)
t2 = Sys.time()
t2 - t1
snow <- SnowParam(workers = 8, type = "FORK")
# system.time(x <- lapply(1:3, function(i) { Sys.sleep(i); i }))
# system.time(x <- bplapply(1:3, function(i) { Sys.sleep(i); i }, BPPARAM = SnowParam(workers = 1, type = "FORK")))
# system.time(x <- bplapply(1:3, function(i) { Sys.sleep(i); i }, BPPARAM = snow))
register(snow)
bpparam()
t3 = Sys.time()
pT <- scMerge(sce_mESC,
ctl = segList_ensemblGeneID$mouse$mouse_scSEG,
kmeansK = c(1,3,3,1,1),
assay_name = "scMerge_classical",
parallel = TRUE,
parallelParam = bpparam())
t4 = Sys.time()
t4 - t3
expect_identical(
assay(pF, "scMerge_classical"),
assay(pT, "scMerge_classical")
)
all.equal(pT, pF)
context("Testing on scReplicate")
library(SingleCellExperiment)
library(scMerge)
library(scMerge.data)
## Loading example data
data("sce_mESC", package = "scMerge.data")
#################### Testing if the fast_svd option yields identical result ####################
set.seed(1)
t1 <- Sys.time()
scRep_fastF <- scReplicate(
sce = sce_mESC,
batch = sce_mESC$batch,
kmeansK = c(1,3,3,1,1),
fast_svd = FALSE)
t2 <- Sys.time()
set.seed(1)
scRep_fastT <- scReplicate(
sce = sce_mESC,
batch = sce_mESC$batch,
kmeansK = c(1,3,3,1,1),
fast_svd = TRUE)
t3 <- Sys.time()
expect_identical(scRep_fastF, scRep_fastT)
## The time for fast_svd = FALSE should be greater than when fast_svd = TRUE
expect_gt(as.numeric(t2 - t1, units = "secs"),
as.numeric(t3 - t2, units = "secs"))
snow <- SnowParam(workers = 1, type = "FORK")
register(snow)
bpparam()
t1 <- Sys.time()
scRep_pT <- scReplicate(
sce = sce_mESC,
batch = sce_mESC$batch,
kmeansK = c(1, 3, 3, 1, 1),
fast_svd = TRUE,
parallelParam = bpparam())
t2 <- Sys.time()
t1 <- Sys.time()
scRep_pT <- scReplicate(
sce = sce_mESC,
batch = sce_mESC$batch,
kmeansK = c(1, 3, 3, 1, 1),
fast_svd = TRUE,
parallelParam = SnowParam(workers = 5, type = "FORK"))
t2 <- Sys.time()
t3 <- Sys.time()
scRep_pF <- scReplicate(
sce = L,
batch = L$dataSource,
kmeansK = rep(10, nBatch),
fast_svd = TRUE,
parallelParam = BiocParallel::SerialParam())
t4 <- Sys.time()
t3 <- Sys.time()
scRep_pF <- scReplicate(
sce = sce_mESC,
batch = sce_mESC$batch,
kmeansK = c(1, 3, 3, 1, 1),
fast_svd = TRUE,
parallelParam = BiocParallel::SerialParam())
t4 <- Sys.time()
expect_identical(scRep_pF, scRep_pT)
as.numeric(t2 - t1, units = "secs")
as.numeric(t3 - t2, units = "secs")
as.numeric(t2 - t1, units = "secs")
as.numeric(t4 - t3, units = "secs")
as.numeric(t2 - t1, units = "secs")
as.numeric(t3 - t2, units = "secs")
roxygenise()
context("Testing on scReplicate")
library(SingleCellExperiment)
library(scMerge)
library(scMerge.data)
## Loading example data
data("sce_mESC", package = "scMerge.data")
#################### Testing if the fast_svd option yields identical result ####################
set.seed(1)
t1 <- Sys.time()
scRep_fastF <- scReplicate(
sce = sce_mESC,
batch = sce_mESC$batch,
kmeansK = c(1,3,3,1,1),
fast_svd = FALSE)
t2 <- Sys.time()
set.seed(1)
scRep_fastT <- scReplicate(
sce = sce_mESC,
batch = sce_mESC$batch,
kmeansK = c(1,3,3,1,1),
fast_svd = TRUE)
t3 <- Sys.time()
expect_identical(scRep_fastF, scRep_fastT)
## The time for fast_svd = FALSE should be greater than when fast_svd = TRUE
expect_gt(as.numeric(t2 - t1, units = "secs"),
as.numeric(t3 - t2, units = "secs"))
context("Testing if parallelisation produce identical results")
## Loading required data
require(SingleCellExperiment)
data("sce_mESC", package = "scMerge.data")
data("segList_ensemblGeneID")
t3 = Sys.time()
pT <- scMerge(sce_mESC,
ctl = segList_ensemblGeneID$mouse$mouse_scSEG,
kmeansK = c(1,3,3,1,1),
assay_name = "scMerge_classical",
parallel = TRUE,
parallelParam = SnowParam(workers = 8, type = "FORK"))
testthat::test_file("tests/testthat/test-parallel-scMerge.R")
BiocCheck::BiocCheck()
roxygenise()
roxygenise()
BiocCheck::BiocCheck()
BiocCheck::BiocCheck()
roxygenise()
library(scMerge)
cluster_res
??
cluster_res
# Chunk 1: setup
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
# Chunk 2: loading packages
suppressPackageStartupMessages({
library(SingleCellExperiment)
library(scMerge)
library(scMerge.data)
library(scater)
})
## mouse ESC data
data("sce_mESC", package = "scMerge.data")
## single-cell stably expressed gene list
data("segList_ensemblGeneID")
table(sce_mESC$batch, sce_mESC$cellTypes)
scater::plotPCA(sce_mESC,
colour_by = "cellTypes",
shape_by = "batch",
add_ticks = FALSE)
sce_mESC <- scMerge(sce_combine = sce_mESC,
ctl = segList_ensemblGeneID$mouse$mouse_scSEG,
kmeansK = c(1,3,3,1,1),
assay_name = "scMerge_unsupervised")
sce_mESC <- scMerge(sce_mESC,
ctl = segList_ensemblGeneID$mouse$mouse_scSEG,
kmeansK = c(1,3,3,1,1),
assay_name = "scMerge_unsupervised_all",
replicate_prop = 1)
sce_mESC <- scMerge(sce_mESC,
ctl = segList_ensemblGeneID$mouse$mouse_scSEG,
kmeansK = c(1,3,3,1,1),
assay_name = "scMerge_supervised",
cell_type = sce_mESC$cellTypes)
sce_mESC <- scMerge(sce_mESC,
ctl = segList_ensemblGeneID$mouse$mouse_scSEG,
kmeansK = c(1,3,3,1,1),
assay_name = "scMerge_semisupervised1",
cell_type = sce_mESC$cellTypes,
cell_type_inc = which(sce_mESC$cellTypes == "2i"))
sce_mESC <- scater::runPCA(sce_mESC,
exprs_values = "scMerge_semisupervised2")
scater::plotPCA(sce_mESC,
colour_by = "cellTypes",
shape_by = "batch",
add_ticks = FALSE)
assayNames(sce_mESC)
sce_mESC <- scater::runPCA(sce_mESC,
exprs_values = "scMerge_semisupervised1")
scater::plotPCA(sce_mESC,
colour_by = "cellTypes",
shape_by = "batch",
add_ticks = FALSE)
sce_mESC <- scMerge(sce_mESC,
ctl = segList_ensemblGeneID$mouse$mouse_scSEG,
kmeansK = c(1,3,3,1,1),
assay_name = "scMerge_semisupervised2",
cell_type = sce_mESC$cellTypes,
cell_type_match = TRUE)
roxygenise()
roxygenize()
library(scMerge)
