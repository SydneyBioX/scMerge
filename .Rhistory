batch <- as.factor(batch)
batch_list <- as.list(as.character(unique(batch)))
## Finding data-adaptive markers, store as object as HVG
if (is.null(marker) & is.null(marker_list)) {
cat("No maker nor marker_list information was supplied \n")
cat("Finding HVG...\n")
exprs_mat_HVG <- SummarizedExperiment::assay(sce_combine, hvg_exprs)
HVG_res <- findHVG(exprs_mat_HVG, batch, parallelParam = parallelParam)
HVG <- HVG_res$HVG
HVG_list <- HVG_res$HVG_list
} else if (!is.null(marker_list) & is.null(marker)) {
## Taking the union of marker_list as HVG
cat("Only marker_list information was supplied \n")
HVG_list <- marker_list
names(HVG_list) <- batch_list
HVG <- Reduce(union, marker_list)
} else {
## If there is only a list of markers, then use that as HVG
HVG <- marker
}
# sce$batch <- as.factor(sce$batch) batch_list <-
# as.list(as.character(unique(sce$batch)))
## For every unique cell_type, calculate the centroid.
clustering_distProp <- lapply(unique(cell_type), function(x) centroidDist(exprs_mat[,
cell_type == x]))
clustering_distProp <- unlist(clustering_distProp)[names(cell_type)]
## For each batch in batch_list, we find the corresponding cell_type_centroid
clustering_distProp_list_batch <- lapply(batch_list, function(x) {
tmp <- clustering_distProp[batch == x]
names(tmp) <- colnames(exprs_mat)[batch == x]
tmp
})
## For each batch in batch_list, we find the corresponding cell_type
cellType_list_batch <- lapply(batch_list, function(x) {
tmp <- as.numeric(droplevels(as.factor(cell_type[batch == x])))
names(tmp) <- colnames(exprs_mat)[batch == x]
tmp
})
## Here, using the cell type information, we go ahead and find MNC
mnc_res <- findMNC(exprs_mat[HVG, ], clustering_list = cellType_list_batch,
dist = dist, parallelParam = parallelParam)
print(mnc_res)
repVector <- mncReplicate(clustering_list = cellType_list_batch, clustering_distProp = clustering_distProp_list_batch,
replicate_prop = replicate_prop, mnc_df = mnc_res)
# if(!is.null(cell_type)&!is.null(cell_type_inc)){ cat('Performing
# semi-supervised scMerge with subsets of known cell type\n')
# repVector[cell_type_inc] <- cell_type[cell_type_inc] } repMat <-
# replicate.matrix(repVector)
} else {
batch <- as.factor(batch)
batch_list <- as.list(as.character(unique(batch)))
## KEVIN: we should move this input check much earlier, into scMerge function
if (is.null(kmeansK)) {
stop("KmeansK is NULL", call. = FALSE)
}
if (length(batch_list) != length(kmeansK)) {
stop("length of KmeansK needs to be the same as the number of batch",
call. = FALSE)
}
## If there are no marker information what so ever, we find the HVG
## adaptively from the data
if (is.null(marker) & is.null(marker_list)) {
cat("No maker nor marker_list information was supplied \n")
cat("Finding HVG...\n")
exprs_mat_HVG <- SummarizedExperiment::assay(sce_combine, hvg_exprs)
HVG_res <- findHVG(exprs_mat_HVG, batch, parallelParam = parallelParam)
HVG <- HVG_res$HVG
HVG_list <- HVG_res$HVG_list
} else if (!is.null(marker_list) & is.null(marker)) {
cat("Only marker_list information was supplied \n")
HVG_list <- marker_list
names(HVG_list) <- batch_list
HVG <- Reduce(union, marker_list)
} else {
HVG <- marker
}
# Clustering within each batch
cat("Clustering within each batch...\n")
cat("Performing pca...\n")
cluster_res <- identifyCluster(exprs_mat = exprs_mat, batch = batch,
marker = marker, HVG_list = HVG_list, kmeansK = kmeansK, parallelParam = parallelParam,
fast_svd = fast_svd)
# Find Mutual Nearest Cluster
cat("Creating Mutual Nearest Cluster...\n")
# if (parallel) { mnc_res <- findMNC_parallel(exprs_mat[HVG, ],
# clustering_list = cluster_res$clustering_list, dist = dist, parallelParam
# = parallelParam) } else { mnc_res <- findMNC(exprs_mat[HVG, ],
# clustering_list = cluster_res$clustering_list, dist = dist) }
mnc_res <- findMNC(exprs_mat = exprs_mat[HVG, ], clustering_list = cluster_res$clustering_list,
dist = dist, parallelParam = parallelParam)
print(mnc_res)
# Create replicate matrix
repVector <- mncReplicate(clustering_list = cluster_res$clustering_list,
clustering_distProp = cluster_res$clustering_distProp, replicate_prop = replicate_prop,
mnc_df = mnc_res)
if (!is.null(cell_type) & !is.null(cell_type_inc)) {
cat("Performing semi-supervised scMerge with subsets of known cell type\n")
repVector[cell_type_inc] <- cell_type[cell_type_inc]
}
if (!is.null(WV)) {
cat("Performing semi-supervised scMerge with wanted variation\n")
repVector <- wvReplicate(exprs_mat, WV, WV_marker, repVector)
}
}
sce_combine = example_sce; batch = NULL; kmeansK = c(3,3); exprs = "logcounts";
hvg_exprs = "counts"; marker = NULL; marker_list = NULL; replicate_prop = 1;
cell_type = NULL; cell_type_match = FALSE; cell_type_inc = NULL; dist = "cor";
WV = NULL; WV_marker = NULL; parallelParam = SerialParam(); return_all = FALSE;
fast_svd = FALSE
exprs_mat <- SummarizedExperiment::assay(sce_combine, exprs)
cellNames = colnames(exprs_mat)
## Based on the input cell_type info, we decide which version of scMerge to
## use.
if (!is.null(cell_type) & is.null(cell_type_inc) & !cell_type_match) {
cat("Cell type information was supplied, and mutual nearest neighbour option was not selected \n")
cat("Performing supervised scMerge \n")
names(cell_type) <- colnames(exprs_mat)
repVector <- supervisedReplicate(exprs_mat, cell_type, replicate_prop)
mnc_res <- NULL
} else if (!is.null(cell_type) & is.null(cell_type_inc) & cell_type_match) {
cat("Cell type information was supplied, and mutual nearest neighbour option was selected \n")
cat("Finding MNC from the known cell types of different batches...\n")
names(cell_type) <- colnames(exprs_mat)
batch <- as.factor(batch)
batch_list <- as.list(as.character(unique(batch)))
## Finding data-adaptive markers, store as object as HVG
if (is.null(marker) & is.null(marker_list)) {
cat("No maker nor marker_list information was supplied \n")
cat("Finding HVG...\n")
exprs_mat_HVG <- SummarizedExperiment::assay(sce_combine, hvg_exprs)
HVG_res <- findHVG(exprs_mat_HVG, batch, parallelParam = parallelParam)
HVG <- HVG_res$HVG
HVG_list <- HVG_res$HVG_list
} else if (!is.null(marker_list) & is.null(marker)) {
## Taking the union of marker_list as HVG
cat("Only marker_list information was supplied \n")
HVG_list <- marker_list
names(HVG_list) <- batch_list
HVG <- Reduce(union, marker_list)
} else {
## If there is only a list of markers, then use that as HVG
HVG <- marker
}
# sce$batch <- as.factor(sce$batch) batch_list <-
# as.list(as.character(unique(sce$batch)))
## For every unique cell_type, calculate the centroid.
clustering_distProp <- lapply(unique(cell_type), function(x) centroidDist(exprs_mat[,
cell_type == x]))
clustering_distProp <- unlist(clustering_distProp)[names(cell_type)]
## For each batch in batch_list, we find the corresponding cell_type_centroid
clustering_distProp_list_batch <- lapply(batch_list, function(x) {
tmp <- clustering_distProp[batch == x]
names(tmp) <- colnames(exprs_mat)[batch == x]
tmp
})
## For each batch in batch_list, we find the corresponding cell_type
cellType_list_batch <- lapply(batch_list, function(x) {
tmp <- as.numeric(droplevels(as.factor(cell_type[batch == x])))
names(tmp) <- colnames(exprs_mat)[batch == x]
tmp
})
## Here, using the cell type information, we go ahead and find MNC
mnc_res <- findMNC(exprs_mat[HVG, ], clustering_list = cellType_list_batch,
dist = dist, parallelParam = parallelParam)
print(mnc_res)
repVector <- mncReplicate(clustering_list = cellType_list_batch, clustering_distProp = clustering_distProp_list_batch,
replicate_prop = replicate_prop, mnc_df = mnc_res)
# if(!is.null(cell_type)&!is.null(cell_type_inc)){ cat('Performing
# semi-supervised scMerge with subsets of known cell type\n')
# repVector[cell_type_inc] <- cell_type[cell_type_inc] } repMat <-
# replicate.matrix(repVector)
} else {
batch <- as.factor(batch)
batch_list <- as.list(as.character(unique(batch)))
## KEVIN: we should move this input check much earlier, into scMerge function
if (is.null(kmeansK)) {
stop("KmeansK is NULL", call. = FALSE)
}
if (length(batch_list) != length(kmeansK)) {
stop("length of KmeansK needs to be the same as the number of batch",
call. = FALSE)
}
## If there are no marker information what so ever, we find the HVG
## adaptively from the data
if (is.null(marker) & is.null(marker_list)) {
cat("No maker nor marker_list information was supplied \n")
cat("Finding HVG...\n")
exprs_mat_HVG <- SummarizedExperiment::assay(sce_combine, hvg_exprs)
HVG_res <- findHVG(exprs_mat_HVG, batch, parallelParam = parallelParam)
HVG <- HVG_res$HVG
HVG_list <- HVG_res$HVG_list
} else if (!is.null(marker_list) & is.null(marker)) {
cat("Only marker_list information was supplied \n")
HVG_list <- marker_list
names(HVG_list) <- batch_list
HVG <- Reduce(union, marker_list)
} else {
HVG <- marker
}
# Clustering within each batch
cat("Clustering within each batch...\n")
cat("Performing pca...\n")
cluster_res <- identifyCluster(exprs_mat = exprs_mat, batch = batch,
marker = marker, HVG_list = HVG_list, kmeansK = kmeansK, parallelParam = parallelParam,
fast_svd = fast_svd)
# Find Mutual Nearest Cluster
cat("Creating Mutual Nearest Cluster...\n")
# if (parallel) { mnc_res <- findMNC_parallel(exprs_mat[HVG, ],
# clustering_list = cluster_res$clustering_list, dist = dist, parallelParam
# = parallelParam) } else { mnc_res <- findMNC(exprs_mat[HVG, ],
# clustering_list = cluster_res$clustering_list, dist = dist) }
mnc_res <- findMNC(exprs_mat = exprs_mat[HVG, ], clustering_list = cluster_res$clustering_list,
dist = dist, parallelParam = parallelParam)
print(mnc_res)
# Create replicate matrix
repVector <- mncReplicate(clustering_list = cluster_res$clustering_list,
clustering_distProp = cluster_res$clustering_distProp, replicate_prop = replicate_prop,
mnc_df = mnc_res)
if (!is.null(cell_type) & !is.null(cell_type_inc)) {
cat("Performing semi-supervised scMerge with subsets of known cell type\n")
repVector[cell_type_inc] <- cell_type[cell_type_inc]
}
if (!is.null(WV)) {
cat("Performing semi-supervised scMerge with wanted variation\n")
repVector <- wvReplicate(exprs_mat, WV, WV_marker, repVector)
}
}
sce_combine = example_sce; batch = example_sce$batch; kmeansK = c(3,3); exprs = "logcounts";
hvg_exprs = "counts"; marker = NULL; marker_list = NULL; replicate_prop = 1;
cell_type = NULL; cell_type_match = FALSE; cell_type_inc = NULL; dist = "cor";
WV = NULL; WV_marker = NULL; parallelParam = SerialParam(); return_all = FALSE;
fast_svd = FALSE
exprs_mat <- SummarizedExperiment::assay(sce_combine, exprs)
cellNames = colnames(exprs_mat)
## Based on the input cell_type info, we decide which version of scMerge to
## use.
if (!is.null(cell_type) & is.null(cell_type_inc) & !cell_type_match) {
cat("Cell type information was supplied, and mutual nearest neighbour option was not selected \n")
cat("Performing supervised scMerge \n")
names(cell_type) <- colnames(exprs_mat)
repVector <- supervisedReplicate(exprs_mat, cell_type, replicate_prop)
mnc_res <- NULL
} else if (!is.null(cell_type) & is.null(cell_type_inc) & cell_type_match) {
cat("Cell type information was supplied, and mutual nearest neighbour option was selected \n")
cat("Finding MNC from the known cell types of different batches...\n")
names(cell_type) <- colnames(exprs_mat)
batch <- as.factor(batch)
batch_list <- as.list(as.character(unique(batch)))
## Finding data-adaptive markers, store as object as HVG
if (is.null(marker) & is.null(marker_list)) {
cat("No maker nor marker_list information was supplied \n")
cat("Finding HVG...\n")
exprs_mat_HVG <- SummarizedExperiment::assay(sce_combine, hvg_exprs)
HVG_res <- findHVG(exprs_mat_HVG, batch, parallelParam = parallelParam)
HVG <- HVG_res$HVG
HVG_list <- HVG_res$HVG_list
} else if (!is.null(marker_list) & is.null(marker)) {
## Taking the union of marker_list as HVG
cat("Only marker_list information was supplied \n")
HVG_list <- marker_list
names(HVG_list) <- batch_list
HVG <- Reduce(union, marker_list)
} else {
## If there is only a list of markers, then use that as HVG
HVG <- marker
}
# sce$batch <- as.factor(sce$batch) batch_list <-
# as.list(as.character(unique(sce$batch)))
## For every unique cell_type, calculate the centroid.
clustering_distProp <- lapply(unique(cell_type), function(x) centroidDist(exprs_mat[,
cell_type == x]))
clustering_distProp <- unlist(clustering_distProp)[names(cell_type)]
## For each batch in batch_list, we find the corresponding cell_type_centroid
clustering_distProp_list_batch <- lapply(batch_list, function(x) {
tmp <- clustering_distProp[batch == x]
names(tmp) <- colnames(exprs_mat)[batch == x]
tmp
})
## For each batch in batch_list, we find the corresponding cell_type
cellType_list_batch <- lapply(batch_list, function(x) {
tmp <- as.numeric(droplevels(as.factor(cell_type[batch == x])))
names(tmp) <- colnames(exprs_mat)[batch == x]
tmp
})
## Here, using the cell type information, we go ahead and find MNC
mnc_res <- findMNC(exprs_mat[HVG, ], clustering_list = cellType_list_batch,
dist = dist, parallelParam = parallelParam)
print(mnc_res)
repVector <- mncReplicate(clustering_list = cellType_list_batch, clustering_distProp = clustering_distProp_list_batch,
replicate_prop = replicate_prop, mnc_df = mnc_res)
# if(!is.null(cell_type)&!is.null(cell_type_inc)){ cat('Performing
# semi-supervised scMerge with subsets of known cell type\n')
# repVector[cell_type_inc] <- cell_type[cell_type_inc] } repMat <-
# replicate.matrix(repVector)
} else {
batch <- as.factor(batch)
batch_list <- as.list(as.character(unique(batch)))
## KEVIN: we should move this input check much earlier, into scMerge function
if (is.null(kmeansK)) {
stop("KmeansK is NULL", call. = FALSE)
}
if (length(batch_list) != length(kmeansK)) {
stop("length of KmeansK needs to be the same as the number of batch",
call. = FALSE)
}
## If there are no marker information what so ever, we find the HVG
## adaptively from the data
if (is.null(marker) & is.null(marker_list)) {
cat("No maker nor marker_list information was supplied \n")
cat("Finding HVG...\n")
exprs_mat_HVG <- SummarizedExperiment::assay(sce_combine, hvg_exprs)
HVG_res <- findHVG(exprs_mat_HVG, batch, parallelParam = parallelParam)
HVG <- HVG_res$HVG
HVG_list <- HVG_res$HVG_list
} else if (!is.null(marker_list) & is.null(marker)) {
cat("Only marker_list information was supplied \n")
HVG_list <- marker_list
names(HVG_list) <- batch_list
HVG <- Reduce(union, marker_list)
} else {
HVG <- marker
}
# Clustering within each batch
cat("Clustering within each batch...\n")
cat("Performing pca...\n")
cluster_res <- identifyCluster(exprs_mat = exprs_mat, batch = batch,
marker = marker, HVG_list = HVG_list, kmeansK = kmeansK, parallelParam = parallelParam,
fast_svd = fast_svd)
# Find Mutual Nearest Cluster
cat("Creating Mutual Nearest Cluster...\n")
# if (parallel) { mnc_res <- findMNC_parallel(exprs_mat[HVG, ],
# clustering_list = cluster_res$clustering_list, dist = dist, parallelParam
# = parallelParam) } else { mnc_res <- findMNC(exprs_mat[HVG, ],
# clustering_list = cluster_res$clustering_list, dist = dist) }
mnc_res <- findMNC(exprs_mat = exprs_mat[HVG, ], clustering_list = cluster_res$clustering_list,
dist = dist, parallelParam = parallelParam)
print(mnc_res)
# Create replicate matrix
repVector <- mncReplicate(clustering_list = cluster_res$clustering_list,
clustering_distProp = cluster_res$clustering_distProp, replicate_prop = replicate_prop,
mnc_df = mnc_res)
if (!is.null(cell_type) & !is.null(cell_type_inc)) {
cat("Performing semi-supervised scMerge with subsets of known cell type\n")
repVector[cell_type_inc] <- cell_type[cell_type_inc]
}
if (!is.null(WV)) {
cat("Performing semi-supervised scMerge with wanted variation\n")
repVector <- wvReplicate(exprs_mat, WV, WV_marker, repVector)
}
}
repVector <- repVector[cellNames]
repVector
repVector %>% summary
repVector %>% table
repMat <- ruv::replicate.matrix(repVector)
repMat
if (return_all) {
return(list(repMat = repMat, mnc = mnc_res, repVector = repVector, HVG = HVG))
} else {
return(repMat)
}
scMerge_supervised <- scMerge(example_sce,
ctl = segList_ensemblGeneID$mouse$mouse_scSEG,
kmeansK = c(3, 3),
assay_name = "scMerge_supervised",
cell_type = example_sce$cellTypes)
data("example_sce")
data(segList_ensemblGeneID)
scMerge_supervised <- scMerge(example_sce,
ctl = segList_ensemblGeneID$mouse$mouse_scSEG,
kmeansK = c(3, 3),
assay_name = "scMerge_supervised",
cell_type = example_sce$cellTypes)
cell_type = example_sce$cellTypes
exprs = "logcounts"
exprs_mat <- SummarizedExperiment::assay(sce_combine, exprs)
cellNames = colnames(exprs_mat)
sce_combine =example_sce
exprs_mat <- SummarizedExperiment::assay(sce_combine, exprs)
cellNames = colnames(exprs_mat)
cat("Cell type information was supplied, and mutual nearest neighbour option was not selected \n")
cat("Performing supervised scMerge \n")
names(cell_type) <- colnames(exprs_mat)
repVector <- supervisedReplicate(exprs_mat, cell_type, replicate_prop)
replicate_prop = 1
repVector <- supervisedReplicate(exprs_mat, cell_type, replicate_prop)
mnc_res <- NULL
repVector
exprs_mat
cell_type
replicate_prop
clustering_distProp <- lapply(unique(cell_type),
function(x) centroidDist(exprs_mat[,cell_type == x]))
clustering_distProp
clustering_distProp <- unlist(clustering_distProp)[names(cell_type)]
clustering_distProp
replicate_vector <- rep(NA, length(cell_type))
replicate_vector
clustering_distProp
clustering_distProp %>% class()
cell_type
names(cell_type)
roxygenise()
example_sce
data(example_sce)
data(segList_ensemblGeneID)
scMerge_supervised <- scMerge(example_sce,
ctl = segList_ensemblGeneID$mouse$mouse_scSEG,
kmeansK = c(3, 3),
assay_name = "scMerge_supervised",
cell_type = example_sce$cellTypes)
scater::plotPCA(scMerge_supervised,
colour_by = "cellTypes",
shape_by = "batch",
run_args = list(exprs_values = "scMerge_supervised"),
add_ticks = FALSE)
citation("scMerge")
roxygenise()
citation("scMerge")
data('example_sce', package = 'scMerge')
## subsetting to 200 genes to illustrate usage.
exprsMat = assay(example_sce, 'counts')[1:200, ]
?assay
roxygenise()
SummarizedExperiment::assay
BiocCheck::BiocCheck()
library(scMerge)
pkgdown::build_site()
library(roxygen2)
roxygenise()
devtools::use_travis()
usethis::use_travis()
usethis::use_travis()
usethis::use_travis()
roxygenise()
usethis::use_travis()
test_check("scMerge")
library(testthat)
library(scMerge)
test_check("scMerge")
?test_check
test_check(".")
is_testing()
context("Inputs of scMerge")
## Input must be an SingleCellExperiment object
expect_error(
scMerge(
sce_combine = matrix(c(0,1,1,1))
)
)
## Input sce must have unique cell names
data("example_sce", package = "scMerge")
example_sce_colnames = example_sce
colnames(example_sce_colnames) = rep("Cell", ncol(example_sce_colnames))
expect_error(
scMerge(
sce_combine = example_sce_colnames
)
)
library(roxygen2)
library(BiocCheck)
roxygenize()
BiocCheck()
library(pkgdown)
library(roxygen2)
roxygenise()
batch_sil
?dist
silhouette
cluster::silhouette
roxygenise()
roxygenise()
BiocCheck::BiocCheck()
roxygenise()
BiocCheck::BiocCheck()
library(roxygen2)
roxygenise()
load("~/Dropbox (Sydney Uni)/Single Cell Reserach/SCProj-Normalization/codes/scMerge/.RData")
ls()
library(pkgdown)
build_site()
build_site()
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("scater", version = "3.9")
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("scater", version = "3.8")
BiocManager::install("scater", version = "3.8")
# Chunk 1: style
BiocStyle::markdown()
# Chunk 2: loading packages
suppressPackageStartupMessages({
library(SingleCellExperiment)
library(scMerge)
library(scater)
})
## Subsetted mouse ESC data
data("example_sce", package = "scMerge")
## single-cell stably expressed gene list
data("segList_ensemblGeneID", package = "scMerge")
scater::plotPCA(example_sce,
colour_by = "cellTypes",
shape_by = "batch",
add_ticks = FALSE)
scater::plotPCA(example_sce,
colour_by = "cellTypes",
shape_by = "batch")
roxygen2::roxygenise()
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("scater", version = "3.9")
